(defvar *data*)

(defun requirements-not-met (reqs done step)
  (some (lambda (x) (not (member x done)))
        (mapcar #'car (remove-if-not (lambda (x)
                                       (eq (cdr x) step))
                                     reqs))))

(defun adv07 ()
  (let ((all (delete-duplicates (append (mapcar #'car *data*)
                                        (mapcar #'cdr *data*))))
        (nonfree (delete-duplicates (mapcar #'cdr *data*))))
    (do ((available (sort (set-difference all nonfree) #'string< :key #'symbol-name)
                    (sort available #'string< :key #'symbol-name))
         (result '()))
        ((null available) (format t "~{~a~}~%" (nreverse result)))
      (let ((next (pop available)))
        (push next result)
        (dolist (step all)
          (unless (or (member step available)
                      (member step result)
                      (requirements-not-met *data* result step))
            (push step available)))))))

(defun step-time (step)
  (+ 61 (- (char-code (char (symbol-name step) 0))
           (char-code #\A))))

(defun adv07b ()
  (let ((all (delete-duplicates (append (mapcar #'car *data*)
                                        (mapcar #'cdr *data*))))
        (nonfree (delete-duplicates (mapcar #'cdr *data*))))
    (do ((available (sort (set-difference all nonfree) #'string< :key #'symbol-name))
         (time 0 (1+ time))
         (underway '())
         (idle 5)
         (result '()))
        ((and (null available) (null underway)) time)
      (loop while (and (> idle 0) available) do
        (let ((next (pop available)))
          (push (cons next (step-time next)) underway)
          (decf idle)))
      (setf underway
            (mapcan (lambda (work)
                      (cond ((> (cdr work) 1)
                             (list (cons (car work) (1- (cdr work)))))
                            (t (push (car work) result)
                               (incf idle)
                               (dolist (step all)
                                 (unless (or (member step available)
                                             (member step underway :key #'car)
                                             (member step result)
                                             (requirements-not-met *data* result step))
                                   (push step available)))
                               (setf available (sort available #'string< :key #'symbol-name))
                               nil)))
                    underway)))))

;;; Data

(defparameter *data*
  '((J . E) (X . G) (D . A) (K . M) (P . Z) (F . O) (B . I) (U . W) (A . R) (E . R) (H . C) (O . S) (Q . Y) (V . W) (T . N) (S . I) (Y . W) (Z . C) (M . L) (L . W) (N . I) (I . G) (C . G) (G . R) (R . W) (Z . R) (Z . N) (G . W) (L . G) (Y . R) (P . I) (C . W) (T . G) (T . R) (V . Z) (L . C) (K . I) (J . I) (Q . C) (F . A) (H . Y) (M . N) (P . H) (M . C) (V . Y) (O . V) (O . Q) (A . G) (T . Z) (K . R) (H . O) (O . Y) (O . C) (K . P) (P . F) (E . M) (M . I) (T . W) (P . L) (A . O) (X . V) (S . G) (A . Y) (J . R) (K . F) (J . A) (P . C) (E . N) (F . Y) (J . D) (H . Z) (U . H) (J . T) (V . G) (Z . I) (H . W) (B . R) (F . B) (X . C) (L . R) (F . U) (D . N) (P . O) (B . O) (F . C) (H . L) (O . N) (J . Y) (H . N) (O . L) (I . W) (J . H) (D . Z) (F . W) (X . W) (Y . M) (T . M) (U . G) (L . I) (N . W) (E . C)))

(defvar *rules*)
(defvar *initial*)

(defun initial-plants (str)
  (let ((result '()))
    (dotimes (i (length str))
      (when (char= (char str i) #\#)
        (push i result)))
    result))

(defun apply-rules (rules plants n)
  (flet ((rule-char (i) (if (member (+ n i) plants) #\# #\.)))
    (let* ((chars (loop for i from -2 to 2 collect (rule-char i)))
           (state (make-array 5 :element-type 'character :initial-contents chars)))
      (char= (cdr (assoc state rules :test #'string=)) #\#))))

(defun sum-after (iterations)
  (let* ((plants (initial-plants *initial*))
         (min (- (reduce #'min plants) 2))
         (max (+ (reduce #'max plants) 2)))
    (dotimes (iter iterations)
      (let ((tmp '()))
        (dotimes (j (1+ (- max min)))
          (when (apply-rules *rules* plants (+ min j))
            (push (+ min j) tmp)))
        (rotatef plants tmp))
      (decf min 2)
      (incf max 2))
    (reduce #'+ plants)))

(defun adv12 ()
  (sum-after 20))

;;; After ~100 iterations it becomes a series of 50 plants which
;;; wanders in the positive direction one step / iteration.
(defun adv12b ()
  (+ (* 50 (- 50000000000 100))
     (sum-after 100)))

;;; Data

(defparameter *initial*
  "###.#..#..##.##.###.#.....#.#.###.#.####....#.##..#.#.#..#....##..#.##...#.###.#.#..#..####.#.##.#")

(defparameter *rules*
  '(("#...." . #\.)
    ("#.##." . #\#)
    ("..#.." . #\.)
    ("#.#.#" . #\.)
    (".#.##" . #\#)
    ("...##" . #\#)
    ("##..." . #\#)
    ("###.." . #\#)
    ("#..##" . #\.)
    (".###." . #\.)
    ("###.#" . #\#)
    ("....." . #\.)
    ("#..#." . #\.)
    (".#.#." . #\#)
    ("##..#" . #\#)
    (".##.." . #\.)
    ("...#." . #\.)
    ("#.###" . #\.)
    ("..###" . #\.)
    ("####." . #\.)
    ("#.#.." . #\#)
    (".##.#" . #\#)
    (".#..." . #\#)
    ("##.#." . #\#)
    ("....#" . #\.)
    ("..#.#" . #\#)
    ("#...#" . #\#)
    ("..##." . #\.)
    (".#..#" . #\#)
    (".####" . #\.)
    ("#####" . #\#)
    ("##.##" . #\#)))

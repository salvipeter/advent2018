(defvar *data*)
(defparameter *ip* 5)

(defparameter *instructions* '())

;;; Almost the same as in Day 16
;;; but builds an alist in *INSTRUCTIONS*
(defmacro instr (name expr)
  (let ((real-name (intern (format nil "INSTR-~a" name))))
    `(progn
       (defun ,real-name (regs a b c)
         (declare (ignorable b))
         (let ((result (copy-list regs)))
           (flet ((r (i) (elt regs i)))
             (declare (ignorable #'r))
             (setf (elt result c) ,expr))
           result))
       (push (cons ',name #',real-name) *instructions*))))

(instr addr (+ (r a) (r b)))
(instr addi (+ (r a) b))
(instr mulr (* (r a) (r b)))
(instr muli (* (r a) b))
(instr banr (logand (r a) (r b)))
(instr bani (logand (r a) b))
(instr borr (logior (r a) (r b)))
(instr bori (logior (r a) b))
(instr setr (r a))
(instr seti a)
(instr gtir (if (> a (r b)) 1 0))
(instr gtri (if (> (r a) b) 1 0))
(instr gtrr (if (> (r a) (r b)) 1 0))
(instr eqir (if (= a (r b)) 1 0))
(instr eqri (if (= (r a) b) 1 0))
(instr eqrr (if (= (r a) (r b)) 1 0))

(defun run (program regs)
  (let ((n (length program)))
    (labels ((rec (regs ip)
               (if (or (< ip 0) (>= ip n))
                   regs
                   (let* ((current (elt program ip))
                          (f (cdr (assoc (car current) *instructions*))))
                     (setf (elt regs *ip*) ip)
                     (let ((next (apply f regs (cdr current))))
                       (rec next (1+ (elt next *ip*))))))))
      (rec regs 0))))

(defun adv19 ()                         ; (sum-of-divisors 877)
  (car (run *data* (list 0 0 0 0 0 0))))

(defun sum-of-divisors (n)
  (loop for k from 1 to n
        when (zerop (mod n k))
          sum k))

(defun adv19b ()
  (sum-of-divisors 10551277))

;;; Data

(defparameter *data*
  '((addi 5 16 5)
    (seti 1 7 3)
    (seti 1 4 1)
    (mulr 3 1 4)
    (eqrr 4 2 4)
    (addr 4 5 5)
    (addi 5 1 5)
    (addr 3 0 0)
    (addi 1 1 1)
    (gtrr 1 2 4)
    (addr 5 4 5)
    (seti 2 1 5)
    (addi 3 1 3)
    (gtrr 3 2 4)
    (addr 4 5 5)
    (seti 1 4 5)
    (mulr 5 5 5)
    (addi 2 2 2)
    (mulr 2 2 2)
    (mulr 5 2 2)
    (muli 2 11 2)
    (addi 4 1 4)
    (mulr 4 5 4)
    (addi 4 19 4)
    (addr 2 4 2)
    (addr 5 0 5)
    (seti 0 9 5)
    (setr 5 7 4)
    (mulr 4 5 4)
    (addr 5 4 4)
    (mulr 5 4 4)
    (muli 4 14 4)
    (mulr 4 5 4)
    (addr 2 4 2)
    (seti 0 9 0)
    (seti 0 6 5)))
